<!doctype html>
	<html>
	<head>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151395790-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-151395790-1');
	</script>	
	<title>ReadNCharactersGivenReadFourIICallmultipletimes</title>
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous">

	<!-- Optional theme -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap-theme.min.css" integrity="sha384-6pzBo3FDv/PJ8r2KRkGHifhEocL+1X2rVCTTkUfGk7/0pbek5mMa1upzvWbrUbOZ" crossorigin="anonymous">

	<!-- Latest compiled and minified JavaScript -->
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script>

	<link rel="stylesheet" href="./web/codepage.css" />
	</head>
	<body>
	<h1>ReadNCharactersGivenReadFourIICallmultipletimes</h1>
	
	<figure class="highlight">
	<pre>
	<code class="language-html">
#include "stdafx.h"

//Given a file and assume that you can only read the file using a given method
//read4, implement a method read to read n characters. Your method read may be
//called multiple times.
// 
//Method read4:
//The API read4 reads 4 consecutive characters from the file, then writes those
//characters into the buffer array buf.
//The return value is the number of actual characters read.
//
//Note that read4() has its own file pointer, much like FILE *fp in C.
//Definition of read4:
//    Parameter:  char[] buf
//    Returns:    int
//
//Note: buf[] is destination not source, the results from read4 will be copied to
//buf[]
//Below is a high level example of how read4 works:
//File file("abcdefghijk"); // File is "abcdefghijk", initially file pointer (fp)
//points to 'a'
//char[] buf = new char[4]; // Create buffer with enough space to store
//characters
//read4(buf); // read4 returns 4. Now buf = "abcd", fp points to 'e'
//read4(buf); // read4 returns 4. Now buf = "efgh", fp points to 'i'
//read4(buf); // read4 returns 3. Now buf = "ijk", fp points to end of file
// 
//Method read:
//By using the read4 method, implement the method read that reads n characters
//from the file and store it in the buffer array buf. Consider that you cannot
//manipulate the file directly.
//The return value is the number of actual characters read.
//Definition of read:
//    Parameters:	char[] buf, int n
//    Returns:	int
//
//Note: buf[] is destination not source, you will need to write the results to
//buf[]
// 
//
//Example 1:
//File file("abc");
//Solution sol;
//// Assume buf is allocated and guaranteed to have enough space for storing all
//characters from the file.
//sol.read(buf, 1); // After calling your read method, buf should contain "a". We
//read a total of 1 character from the file, so return 1.
//sol.read(buf, 2); // Now buf should contain "bc". We read a total of 2
//characters from the file, so return 2.
//sol.read(buf, 1); // We have reached the end of file, no more characters can be
//read. So return 0.
//
//Example 2:
//File file("abc");
//Solution sol;
//sol.read(buf, 4); // After calling your read method, buf should contain "abc".
//We read a total of 3 characters from the file, so return 3.
//sol.read(buf, 1); // We have reached the end of file, no more characters can be
//read. So return 0.
// 
//
//Note:
//Consider that you cannot manipulate the file directly, the file is only
//accesible for read4 but not for read.
//The read function may be called multiple times.
//Please remember to RESET your class variables declared in Solution, as
//static/class variables are persisted across multiple test cases. Please see
//here for more details.
//You may assume the destination buffer array, buf, is guaranteed to have enough
//space for storing n characters.
//It is guaranteed that in a given test case the same buffer buf is called by
//read.

namespace Solution2019
{
	namespace ReadNCharactersGivenReadFourIICallmultipletimes
	{
		int read4(char* buf) { return 0; };

		char buf4[4];
		int i4 = 0;
		int n4 = 0;
		/**
		 * @param buf Destination buffer
		 * @param n   Number of characters to read
		 * @return    The number of actual characters read
		 */
		int read(char* buf, int n) {
			int i = 0;
			while (i &lt; n) {
				if (i4 == n4) {
					i4 = 0;
					n4 = read4(buf4);
					if (n4 == 0) { break; }
				}
				buf[i] = buf4[i4];
				i++;
				i4++;
			}
			return i;
		}

		void Main() {
			string test = "tst test test";
			print(test);
		}
	}
}


	</code>
	</pre>
	</figure>
	
	</body>
	</html>
	